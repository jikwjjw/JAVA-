+ 前序遍历：访问根结点的操作发生在遍历其左右子树之前。根左右
+ 中序遍历：访问根结点的操作发生在遍历其左右子树之中。左根右
+ 后序遍历：访问根结点的操作发生在遍历其左右子树之后。左右根
------------------------------------------------------
+ 左旋：以某个结点作为支点(旋转结点)，其右子结点变为旋转结点的父结点，右子结点的左子结点变为旋转结点的右子结点，左子结点保持不变。
+ 右旋：以某个结点作为支点(旋转结点)，其左子结点变为旋转结点的父结点，左子结点的右子结点变为旋转结点的左子结点，右子结点保持不变
+ 变色：结点的颜色由红变黑或由黑变红
-----------------------------------------
+ 二叉查找树（Binary Search Tree），（又：二叉搜索树，二叉排序树） 一棵空树，或者是具有下列性质的二叉树：
  + 若左子树不空，则左子树上所有结点的值均小于它的根结点的值；
  + 若右子树不空，则右子树上所有结点的值均大于它的根结点的值；
  + 左、右子树也分别为二叉排序树；
  + 没有键值相等的结点。
----------------------------------------------
+ 平衡二叉树（Balanced Binary Tree）（AVL树）：空树或者任一结点左、右子树高度差的绝对值不超过1，非叶子节值大于左边子节点、小于右边子节点；
----------------------------------------------------------------------
+ 红黑树：平衡二叉树，通过对任何一条从根到叶子的简单路径上各个节点的颜色进行约束，确保没有一条路径会比其他路径长2倍，因而是近似平衡的。所以相对于严格要求平衡的AVL树来说，它的旋转保持平衡次数较少。用于搜索时，插入删除次数多的情况下我们就用红黑树来取代AVL。

--------------------------
+ B树(B-树)：是一种多路搜索树（并不是二叉的），m代表最多有m个子树，一般也成为m阶B树
  + 定义任意非叶子结点最多只有M个儿子；且M>2；
  + 根结点的儿子数为[2, M]；
  + 除根结点以外的非叶子结点的儿子数为[M/2, M]；
  + 每个非根结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字）
  + 非叶子结点的关键字个数=指向儿子的指针个数-1；
  + 非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] < K[i+1]；
  + 非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；
  + 所有叶子结点位于同一层；
---------------------------------------
+ B+树：其定义基本与B-树同，除了：
  + 非叶子结点的子树指针与关键字个数相同。
  + 非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树（B-树是开区间）；
  + 为所有叶子结点增加一个链指针，指向其他叶子节点
  + 所有关键字都在叶子结点出现；
------------------------
+ B*/树：其定义基本与B+树同，除了：
  + 是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针
  + B*/树定义了非叶子结点关键字个数至少为(2/3)*M，即块的最低使用率为2/3（代替B+树的1/2）
 --------------------------------
+ 红黑树：红黑树是一种含有红黑结点并能自平衡的二叉查找树,关键性质：从根到叶子的最长的可能路径不多于最短的可能路径的两倍长
  + 每个节点要么是黑色，要么是红色。
  + 根节点是黑色
  + 每个叶子节点（NIL）是黑色。在Java中，叶子结点是为null的结点
  + 每个红色结点的两个子结点一定都是黑色。
  + 任意一结点到每个叶子结点的路径都包含数量相同的黑结点
  + 如果一个结点存在黑子结点，那么该结点肯定有两个子结点
-------------------------------------------
+ 二叉树的高度：
  + 计算公式：return (int)(Math.log(vals.length+1)/Math.log(2))+1;
